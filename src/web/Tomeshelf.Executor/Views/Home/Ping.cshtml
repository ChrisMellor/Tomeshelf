@model ExecutorConfigurationViewModel
@{
    ViewData["Title"] = "Ping Endpoint";
}

<h1 class="mb-3">Ping Endpoint</h1>
<p class="text-muted">Send a one-off request to verify an endpoint without adding it to the scheduler.</p>

@if (TempData["StatusMessage"] is string statusMessage)
{
    <div class="alert alert-success">@statusMessage</div>
}

<form asp-action="Ping" method="post" class="mt-3">
    @Html.AntiForgeryToken()
    <div asp-validation-summary="ModelOnly" class="alert alert-danger"></div>
    @if (Model.ApiServices.Count > 0)
    {
        <div class="row mb-3">
            <div class="col-md-6">
                <label for="ping-api-selector" class="form-label">API Base URL</label>
                <select id="ping-api-selector" class="form-select" aria-label="API base URL selector">
                    <option value="">Select an API</option>
                    @foreach (var api in Model.ApiServices)
                    {
                        <option value="@api.BaseAddress" data-service-name="@api.ServiceName">
                            @($"{api.DisplayName} - {api.BaseAddress}")
                        </option>
                    }
                </select>
                <div class="form-text">Selecting an API helps populate the target URL automatically.</div>
            </div>
            <div class="col-md-6">
                <label for="ping-endpoint-selector" class="form-label">Endpoint</label>
                <select id="ping-endpoint-selector" class="form-select" aria-label="Endpoint selector" disabled>
                    <option value="">Select an endpoint</option>
                </select>
                <div class="form-text">Selecting an endpoint fills in the URL and HTTP method.</div>
            </div>
        </div>
    }
    <div class="row mb-3">
        <div class="col-md-4">
            <label asp-for="Ping.Method" class="form-label"></label>
            <input asp-for="Ping.Method" class="form-control" />
            <span asp-validation-for="Ping.Method" class="text-danger"></span>
        </div>
        <div class="col-md-8">
            <label asp-for="Ping.Url" class="form-label"></label>
            <input asp-for="Ping.Url" class="form-control" />
            <span asp-validation-for="Ping.Url" class="text-danger"></span>
        </div>
    </div>
    <div class="mb-3">
        <label asp-for="Ping.Headers" class="form-label"></label>
        <textarea asp-for="Ping.Headers" class="form-control" rows="2"></textarea>
        <span asp-validation-for="Ping.Headers" class="text-danger"></span>
        <div class="form-text">Optional headers, enter one per line as key:value.</div>
    </div>
    <div class="d-flex align-items-center">
        <button type="submit" class="btn btn-outline-primary me-2">Send Ping</button>
        <a asp-action="Index" class="btn btn-outline-secondary">Back to Dashboard</a>
    </div>
</form>

@if (Model.PingResult is not null)
{
    var alertClass = Model.PingResult.Success ? "alert-success" : "alert-danger";
    <div class="alert @alertClass mt-4">
        <div><strong>Status:</strong> @(Model.PingResult.StatusCode?.ToString() ?? "n/a")</div>
        <div><strong>Message:</strong> @Model.PingResult.Message</div>
        <div><strong>Duration:</strong> @($"{Model.PingResult.Duration.TotalMilliseconds:N0} ms")</div>
        @if (!string.IsNullOrEmpty(Model.PingResult.ResponseBody))
        {
            <hr />
            <div><strong>Body:</strong></div>
            <pre class="mb-0 small text-break">@Model.PingResult.ResponseBody</pre>
        }
    </div>
}

@section Scripts {
    <partial name="_ValidationScriptsPartial"/>
    @if (Model.ApiServices.Count > 0)
    {
        <script>
            (() => {
                const apiSelect = document.getElementById('ping-api-selector');
                const endpointSelect = document.getElementById('ping-endpoint-selector');
                const urlInput = document.getElementById('Ping_Url');
                const methodInput = document.getElementById('Ping_Method');
                const discoveryUrl = '@Url.Action("GetDiscoveredEndpoints", "Home")';

                if (!apiSelect || !endpointSelect || !urlInput || !methodInput) {
                    return;
                }

                const resetEndpoints = (placeholder = 'Select an endpoint') => {
                    endpointSelect.innerHTML = '';
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = placeholder;
                    endpointSelect.appendChild(option);
                    endpointSelect.disabled = true;
                    endpointSelect.dataset.base = '';
                };

                resetEndpoints();

                apiSelect.addEventListener('change', async () => {
                    const baseUri = apiSelect.value;
                    if (!baseUri) {
                        resetEndpoints();
                        return;
                    }

                    endpointSelect.dataset.base = baseUri;
                    endpointSelect.disabled = true;
                    endpointSelect.innerHTML = '';
                    const loading = document.createElement('option');
                    loading.value = '';
                    loading.textContent = 'Loading endpoints...';
                    endpointSelect.appendChild(loading);

                    try {
                        const response = await fetch(`${discoveryUrl}?baseUri=${encodeURIComponent(baseUri)}`);
                        if (!response.ok) {
                            throw new Error(`Failed to load endpoints (${response.status}).`);
                        }

                        const endpoints = await response.json();
                        if (!Array.isArray(endpoints) || endpoints.length === 0) {
                            resetEndpoints('No endpoints discovered');
                            return;
                        }

                        endpointSelect.innerHTML = '';
                        const placeholder = document.createElement('option');
                        placeholder.value = '';
                        placeholder.textContent = 'Select an endpoint';
                        endpointSelect.appendChild(placeholder);

                        endpoints.forEach(endpoint => {
                            const option = document.createElement('option');
                            option.value = endpoint.id ?? endpoint.relativePath ?? '';
                            option.dataset.method = endpoint.method ?? '';
                            option.dataset.relativePath = endpoint.relativePath ?? '';

                            let label = `${endpoint.method ?? ''} ${endpoint.relativePath ?? ''}`.trim();
                            if (endpoint.description) {
                                label = `${label} (${endpoint.description})`;
                            }

                            option.textContent = label || (endpoint.displayName ?? 'Endpoint');
                            option.title = endpoint.displayName ?? label;
                            endpointSelect.appendChild(option);
                        });

                        endpointSelect.disabled = false;
                    } catch (error) {
                        console.error(error);
                        resetEndpoints('Failed to load endpoints');
                    }
                });

                endpointSelect.addEventListener('change', () => {
                    const selected = endpointSelect.selectedOptions[0];
                    if (!selected) {
                        return;
                    }

                    const selectedMethod = selected.dataset.method;
                    const relativePath = selected.dataset.relativePath;
                    const baseUri = endpointSelect.dataset.base ?? '';

                    if (selectedMethod) {
                        methodInput.value = selectedMethod;
                    }

                    if (baseUri && relativePath) {
                        const normalizedBase = baseUri.replace(/\/+$/, '');
                        const normalizedPath = relativePath.startsWith('/') ? relativePath : `/${relativePath}`;
                        urlInput.value = `${normalizedBase}${normalizedPath}`;
                    }
                });
            })();
        </script>
    }
}
